{"version":3,"sources":["../node_modules/@larva.io/webcomponents/dist/esm/index-16db53ae.js"],"names":["CSS_VALUE_REGEX","TRANSFORM_PROPS","win","window","raf","requestAnimationFrame","bind","f","Date","now","Animator","this","_hasDur","_hasTweenEffect","_isAsync","_isReverse","_destroyed","hasChildren","isPlaying","hasCompleted","el","length","i","_addEl","nodeType","_elements","push","childAnimation","parent","_childAnimations","opts","undefined","duration","_duration","getDuration","milliseconds","_reversedEasingName","_easingName","getEasing","name","prop","val","_addProp","clearProperyAfterTransition","fx","afterClearStyles","trans","fromVal","toVal","from","to","_fxProperties","find","effectName","state","fxProp","_getProp","shouldTrans","wc","fxState","num","effectUnit","indexOf","r","match","parseFloat","isNaN","className","_beforeAddClasses","_beforeRemoveClasses","styles","_beforeStyles","propertyNames","domReadFn","_readCallbacks","domWriteFn","_writeCallbacks","_afterAddClasses","_afterRemoveClasses","_afterStyles","_hasDuration","_clearAsync","_playInit","_playDomInspect","Promise","resolve","onFinish","oneTimeCallback","clearExistingCallbacks","play","children","_progress","_willChange","_beforeAnimation","dur","_asyncEnd","_playProgress","_playToStep","_setTrans","_setAfterStyles","_didFinish","stepValue","shouldComplete","self","_unregisterTrnsEnd","callback","unRegTrans","passive","unregister","onTransitionEnd","ev","target","addEventListener","removeEventListener","transitionEnd","_transEl","_playEnd","_didFinishAll","_timerId","setTimeout","console","debug","_hasDomReads","clearTimeout","elements","effects","j","finalTransform","fromNum","toNum","tweenEffect","style","setProperty","forcedLinearEasing","easing","durString","transitionDuration","transitionTimingFunction","_fireBeforeReadFunc","_fireBeforeWriteFunc","_setBeforeStyles","addClasses","removeClasses","elementClassList","classList","c","add","remove","Object","entries","key","value","readFunctions","writeFunctions","beforeAddClasses","beforeRemoveClasses","beforeStyles","keys","propName","removeProperty","afterAddClasses","afterRemoveClasses","afterStyles","addWillChange","willChange","propWC","join","_progressStart","Math","min","max","progressStep","currentStepValue","diff","abs","_progressEnd","isAsync","_onFinishCallbacks","_onFinishOneTimeCallbacks","finishAsyncAnimations","finishNoDurationAnimations","shouldReverse","child","reverse","destroy","targetEl","create","animationBuilder","baseEl"],"mappings":"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","file":"static/js/2.800e0a0d.chunk.js","sourcesContent":["function transitionEnd(el, callback) {\n  let unRegTrans;\n  const opts = { passive: true };\n  function unregister() {\n    if (unRegTrans) {\n      unRegTrans();\n    }\n  }\n  function onTransitionEnd(ev) {\n    if (el === ev.target) {\n      unregister();\n      callback(ev);\n    }\n  }\n  if (el) {\n    el.addEventListener('webkitTransitionEnd', onTransitionEnd, opts);\n    el.addEventListener('transitionend', onTransitionEnd, opts);\n    unRegTrans = () => {\n      el.removeEventListener('webkitTransitionEnd', onTransitionEnd, opts);\n      el.removeEventListener('transitionend', onTransitionEnd, opts);\n    };\n  }\n  return unregister;\n}\n\nconst CSS_VALUE_REGEX = /(^-?\\d*\\.?\\d*)(.*)/;\nconst DURATION_MIN = 32;\nconst TRANSITION_END_FALLBACK_PADDING_MS = 400;\nconst TRANSFORM_PROPS = {\n  'translateX': 1,\n  'translateY': 1,\n  'translateZ': 1,\n  'scale': 1,\n  'scaleX': 1,\n  'scaleY': 1,\n  'scaleZ': 1,\n  'rotate': 1,\n  'rotateX': 1,\n  'rotateY': 1,\n  'rotateZ': 1,\n  'skewX': 1,\n  'skewY': 1,\n  'perspective': 1\n};\nconst win = typeof window !== 'undefined' ? window : {};\nconst raf = win.requestAnimationFrame\n  ? win.requestAnimationFrame.bind(win)\n  : (f) => f(Date.now());\nclass Animator {\n  constructor() {\n    this._hasDur = false;\n    this._hasTweenEffect = false;\n    this._isAsync = false;\n    this._isReverse = false;\n    this._destroyed = false;\n    this.hasChildren = false;\n    this.isPlaying = false;\n    this.hasCompleted = false;\n  }\n  addElement(el) {\n    if (el != null) {\n      if (el.length > 0) {\n        for (let i = 0; i < el.length; i++) {\n          this._addEl(el[i]);\n        }\n      }\n      else {\n        this._addEl(el);\n      }\n    }\n    return this;\n  }\n  /**\n   * NO DOM\n   */\n  _addEl(el) {\n    if (el.nodeType === 1) {\n      (this._elements = this._elements || []).push(el);\n    }\n  }\n  /**\n   * Add a child animation to this animation.\n   */\n  add(childAnimation) {\n    childAnimation.parent = this;\n    this.hasChildren = true;\n    (this._childAnimations = this._childAnimations || []).push(childAnimation);\n    return this;\n  }\n  /**\n   * Get the duration of this animation. If this animation does\n   * not have a duration, then it'll get the duration from its parent.\n   */\n  getDuration(opts) {\n    if (opts && opts.duration !== undefined) {\n      return opts.duration;\n    }\n    else if (this._duration !== undefined) {\n      return this._duration;\n    }\n    else if (this.parent) {\n      return this.parent.getDuration();\n    }\n    return 0;\n  }\n  /**\n   * Returns if the animation is a root one.\n   */\n  isRoot() {\n    return !this.parent;\n  }\n  /**\n   * Set the duration for this animation.\n   */\n  duration(milliseconds) {\n    this._duration = milliseconds;\n    return this;\n  }\n  /**\n   * Get the easing of this animation. If this animation does\n   * not have an easing, then it'll get the easing from its parent.\n   */\n  getEasing() {\n    if (this._isReverse && this._reversedEasingName !== undefined) {\n      return this._reversedEasingName;\n    }\n    return this._easingName !== undefined ? this._easingName : (this.parent && this.parent.getEasing()) || null;\n  }\n  /**\n   * Set the easing for this animation.\n   */\n  easing(name) {\n    this._easingName = name;\n    return this;\n  }\n  /**\n   * Set the easing for this reversed animation.\n   */\n  easingReverse(name) {\n    this._reversedEasingName = name;\n    return this;\n  }\n  /**\n   * Add the \"from\" value for a specific property.\n   */\n  from(prop, val) {\n    this._addProp('from', prop, val);\n    return this;\n  }\n  /**\n   * Add the \"to\" value for a specific property.\n   */\n  to(prop, val, clearProperyAfterTransition = false) {\n    const fx = this._addProp('to', prop, val);\n    if (clearProperyAfterTransition) {\n      // if this effect is a transform then clear the transform effect\n      // otherwise just clear the actual property\n      this.afterClearStyles([fx.trans ? 'transform' : prop]);\n    }\n    return this;\n  }\n  /**\n   * Shortcut to add both the \"from\" and \"to\" for the same property.\n   */\n  fromTo(prop, fromVal, toVal, clearProperyAfterTransition) {\n    return this.from(prop, fromVal).to(prop, toVal, clearProperyAfterTransition);\n  }\n  /**\n   * NO DOM\n   */\n  _getProp(name) {\n    if (this._fxProperties) {\n      return this._fxProperties.find(prop => prop.effectName === name);\n    }\n    return undefined;\n  }\n  _addProp(state, prop, val) {\n    let fxProp = this._getProp(prop);\n    if (!fxProp) {\n      // first time we've see this EffectProperty\n      const shouldTrans = (TRANSFORM_PROPS[prop] === 1);\n      fxProp = {\n        effectName: prop,\n        trans: shouldTrans,\n        // add the will-change property for transforms or opacity\n        wc: (shouldTrans ? 'transform' : prop)\n      };\n      (this._fxProperties = this._fxProperties || []).push(fxProp);\n    }\n    // add from/to EffectState to the EffectProperty\n    const fxState = {\n      val,\n      num: 0,\n      effectUnit: '',\n    };\n    fxProp[state] = fxState;\n    if (typeof val === 'string' && val.indexOf(' ') < 0) {\n      const r = val.match(CSS_VALUE_REGEX);\n      if (r) {\n        const num = parseFloat(r[1]);\n        if (!isNaN(num)) {\n          fxState.num = num;\n        }\n        fxState.effectUnit = (r[0] !== r[2] ? r[2] : '');\n      }\n    }\n    else if (typeof val === 'number') {\n      fxState.num = val;\n    }\n    return fxProp;\n  }\n  /**\n   * Add CSS class to this animation's elements\n   * before the animation begins.\n   */\n  beforeAddClass(className) {\n    (this._beforeAddClasses = this._beforeAddClasses || []).push(className);\n    return this;\n  }\n  /**\n   * Remove CSS class from this animation's elements\n   * before the animation begins.\n   */\n  beforeRemoveClass(className) {\n    (this._beforeRemoveClasses = this._beforeRemoveClasses || []).push(className);\n    return this;\n  }\n  /**\n   * Set CSS inline styles to this animation's elements\n   * before the animation begins.\n   */\n  beforeStyles(styles) {\n    this._beforeStyles = styles;\n    return this;\n  }\n  /**\n   * Clear CSS inline styles from this animation's elements\n   * before the animation begins.\n   */\n  beforeClearStyles(propertyNames) {\n    this._beforeStyles = this._beforeStyles || {};\n    for (const prop of propertyNames) {\n      this._beforeStyles[prop] = '';\n    }\n    return this;\n  }\n  /**\n   * Add a function which contains DOM reads, which will run\n   * before the animation begins.\n   */\n  beforeAddRead(domReadFn) {\n    (this._readCallbacks = this._readCallbacks || []).push(domReadFn);\n    return this;\n  }\n  /**\n   * Add a function which contains DOM writes, which will run\n   * before the animation begins.\n   */\n  beforeAddWrite(domWriteFn) {\n    (this._writeCallbacks = this._writeCallbacks || []).push(domWriteFn);\n    return this;\n  }\n  /**\n   * Add CSS class to this animation's elements\n   * after the animation finishes.\n   */\n  afterAddClass(className) {\n    (this._afterAddClasses = this._afterAddClasses || []).push(className);\n    return this;\n  }\n  /**\n   * Remove CSS class from this animation's elements\n   * after the animation finishes.\n   */\n  afterRemoveClass(className) {\n    (this._afterRemoveClasses = this._afterRemoveClasses || []).push(className);\n    return this;\n  }\n  /**\n   * Set CSS inline styles to this animation's elements\n   * after the animation finishes.\n   */\n  afterStyles(styles) {\n    this._afterStyles = styles;\n    return this;\n  }\n  /**\n   * Clear CSS inline styles from this animation's elements\n   * after the animation finishes.\n   */\n  afterClearStyles(propertyNames) {\n    this._afterStyles = this._afterStyles || {};\n    for (const prop of propertyNames) {\n      this._afterStyles[prop] = '';\n    }\n    return this;\n  }\n  /**\n   * Play the animation.\n   */\n  play(opts) {\n    // If the animation was already invalidated (it did finish), do nothing\n    if (this._destroyed) {\n      return;\n    }\n    // this is the top level animation and is in full control\n    // of when the async play() should actually kick off\n    // if there is no duration then it'll set the TO property immediately\n    // if there is a duration, then it'll stage all animations at the\n    // FROM property and transition duration, wait a few frames, then\n    // kick off the animation by setting the TO property for each animation\n    this._isAsync = this._hasDuration(opts);\n    // ensure all past transition end events have been cleared\n    this._clearAsync();\n    // recursively kicks off the correct progress step for each child animation\n    // ******** DOM WRITE ****************\n    this._playInit(opts);\n    // doubling up RAFs since this animation was probably triggered\n    // from an input event, and just having one RAF would have this code\n    // run within the same frame as the triggering input event, and the\n    // input event probably already did way too much work for one frame\n    raf(() => {\n      raf(() => {\n        this._playDomInspect(opts);\n      });\n    });\n  }\n  playAsync(opts) {\n    return new Promise(resolve => {\n      this.onFinish(resolve, { oneTimeCallback: true, clearExistingCallbacks: true });\n      this.play(opts);\n      return this;\n    });\n  }\n  playSync() {\n    // If the animation was already invalidated (it did finish), do nothing\n    if (!this._destroyed) {\n      const opts = { duration: 0 };\n      this._isAsync = false;\n      this._clearAsync();\n      this._playInit(opts);\n      this._playDomInspect(opts);\n    }\n  }\n  /**\n   * DOM WRITE\n   * RECURSION\n   */\n  _playInit(opts) {\n    // always default that an animation does not tween\n    // a tween requires that an Animation class has an element\n    // and that it has at least one FROM/TO effect\n    // and that the FROM/TO effect can tween numeric values\n    this._hasTweenEffect = false;\n    this.isPlaying = true;\n    this.hasCompleted = false;\n    this._hasDur = (this.getDuration(opts) > DURATION_MIN);\n    const children = this._childAnimations;\n    if (children) {\n      for (const child of children) {\n        // ******** DOM WRITE ****************\n        child._playInit(opts);\n      }\n    }\n    if (this._hasDur) {\n      // if there is a duration then we want to start at step 0\n      // ******** DOM WRITE ****************\n      this._progress(0);\n      // add the will-change properties\n      // ******** DOM WRITE ****************\n      this._willChange(true);\n    }\n  }\n  /**\n   * DOM WRITE\n   * NO RECURSION\n   * ROOT ANIMATION\n   */\n  _playDomInspect(opts) {\n    // fire off all the \"before\" function that have DOM READS in them\n    // elements will be in the DOM, however visibily hidden\n    // so we can read their dimensions if need be\n    // ******** DOM READ ****************\n    // ******** DOM WRITE ****************\n    this._beforeAnimation();\n    // for the root animation only\n    // set the async TRANSITION END event\n    // and run onFinishes when the transition ends\n    const dur = this.getDuration(opts);\n    if (this._isAsync) {\n      this._asyncEnd(dur, true);\n    }\n    // ******** DOM WRITE ****************\n    this._playProgress(opts);\n    if (this._isAsync && !this._destroyed) {\n      // this animation has a duration so we need another RAF\n      // for the CSS TRANSITION properties to kick in\n      raf(() => {\n        this._playToStep(1);\n      });\n    }\n  }\n  /**\n   * DOM WRITE\n   * RECURSION\n   */\n  _playProgress(opts) {\n    const children = this._childAnimations;\n    if (children) {\n      for (const child of children) {\n        // ******** DOM WRITE ****************\n        child._playProgress(opts);\n      }\n    }\n    if (this._hasDur) {\n      // set the CSS TRANSITION duration/easing\n      // ******** DOM WRITE ****************\n      this._setTrans(this.getDuration(opts), false);\n    }\n    else {\n      // this animation does not have a duration, so it should not animate\n      // just go straight to the TO properties and call it done\n      // ******** DOM WRITE ****************\n      this._progress(1);\n      // since there was no animation, immediately run the after\n      // ******** DOM WRITE ****************\n      this._setAfterStyles();\n      // this animation has no duration, so it has finished\n      // other animations could still be running\n      this._didFinish(true);\n    }\n  }\n  /**\n   * DOM WRITE\n   * RECURSION\n   */\n  _playToStep(stepValue) {\n    if (!this._destroyed) {\n      const children = this._childAnimations;\n      if (children) {\n        for (const child of children) {\n          // ******** DOM WRITE ****************\n          child._playToStep(stepValue);\n        }\n      }\n      if (this._hasDur) {\n        // browser had some time to render everything in place\n        // and the transition duration/easing is set\n        // now set the TO properties which will trigger the transition to begin\n        // ******** DOM WRITE ****************\n        this._progress(stepValue);\n      }\n    }\n  }\n  /**\n   * DOM WRITE\n   * NO RECURSION\n   * ROOT ANIMATION\n   */\n  _asyncEnd(dur, shouldComplete) {\n    const self = this;\n    function onTransitionEnd() {\n      // congrats! a successful transition completed!\n      // ensure transition end events and timeouts have been cleared\n      self._clearAsync();\n      // ******** DOM WRITE ****************\n      self._playEnd();\n      // transition finished\n      self._didFinishAll(shouldComplete, true, false);\n    }\n    function onTransitionFallback() {\n      console.debug('Animation onTransitionFallback, CSS onTransitionEnd did not fire!');\n      // oh noz! the transition end event didn't fire in time!\n      // instead the fallback timer when first\n      // if all goes well this fallback should never fire\n      // clear the other async end events from firing\n      self._timerId = undefined;\n      self._clearAsync();\n      // set the after styles\n      // ******** DOM WRITE ****************\n      self._playEnd(shouldComplete ? 1 : 0);\n      // transition finished\n      self._didFinishAll(shouldComplete, true, false);\n    }\n    // set the TRANSITION END event on one of the transition elements\n    self._unregisterTrnsEnd = transitionEnd(self._transEl(), onTransitionEnd);\n    // set a fallback timeout if the transition end event never fires, or is too slow\n    // transition end fallback: (animation duration + XXms)\n    self._timerId = setTimeout(onTransitionFallback, (dur + TRANSITION_END_FALLBACK_PADDING_MS));\n  }\n  /**\n   * DOM WRITE\n   * RECURSION\n   */\n  _playEnd(stepValue) {\n    const children = this._childAnimations;\n    if (children) {\n      for (const child of children) {\n        // ******** DOM WRITE ****************\n        child._playEnd(stepValue);\n      }\n    }\n    if (this._hasDur) {\n      if (stepValue !== undefined) {\n        // too late to have a smooth animation, just finish it\n        // ******** DOM WRITE ****************\n        this._setTrans(0, true);\n        // ensure the ending progress step gets rendered\n        // ******** DOM WRITE ****************\n        this._progress(stepValue);\n      }\n      // set the after styles\n      // ******** DOM WRITE ****************\n      this._setAfterStyles();\n      // remove the will-change properties\n      // ******** DOM WRITE ****************\n      this._willChange(false);\n    }\n  }\n  /**\n   * NO DOM\n   * RECURSION\n   */\n  _hasDuration(opts) {\n    if (this.getDuration(opts) > DURATION_MIN) {\n      return true;\n    }\n    const children = this._childAnimations;\n    if (children) {\n      for (const child of children) {\n        if (child._hasDuration(opts)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * NO DOM\n   * RECURSION\n   */\n  _hasDomReads() {\n    if (this._readCallbacks && this._readCallbacks.length > 0) {\n      return true;\n    }\n    const children = this._childAnimations;\n    if (children) {\n      for (const child of children) {\n        if (child._hasDomReads()) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Immediately stop at the end of the animation.\n   */\n  stop(stepValue = 1) {\n    // ensure all past transition end events have been cleared\n    this._clearAsync();\n    this._hasDur = true;\n    this._playEnd(stepValue);\n  }\n  /**\n   * NO DOM\n   * NO RECURSION\n   */\n  _clearAsync() {\n    if (this._unregisterTrnsEnd) {\n      this._unregisterTrnsEnd();\n    }\n    if (this._timerId) {\n      clearTimeout(this._timerId);\n    }\n    this._timerId = this._unregisterTrnsEnd = undefined;\n  }\n  /**\n   * DOM WRITE\n   * NO RECURSION\n   */\n  _progress(stepValue) {\n    // bread 'n butter\n    let val;\n    const elements = this._elements;\n    const effects = this._fxProperties;\n    if (!elements || elements.length === 0 || !effects || this._destroyed) {\n      return;\n    }\n    // flip the number if we're going in reverse\n    if (this._isReverse) {\n      stepValue = 1 - stepValue;\n    }\n    let i = 0;\n    let j = 0;\n    let finalTransform = '';\n    let fx;\n    for (i = 0; i < effects.length; i++) {\n      fx = effects[i];\n      if (fx.from && fx.to) {\n        const fromNum = fx.from.num;\n        const toNum = fx.to.num;\n        const tweenEffect = (fromNum !== toNum);\n        if (tweenEffect) {\n          this._hasTweenEffect = true;\n        }\n        if (stepValue === 0) {\n          // FROM\n          val = fx.from.val;\n        }\n        else if (stepValue === 1) {\n          // TO\n          val = fx.to.val;\n        }\n        else if (tweenEffect) {\n          // EVERYTHING IN BETWEEN\n          const valNum = (((toNum - fromNum) * stepValue) + fromNum);\n          const unit = fx.to.effectUnit;\n          val = valNum + unit;\n        }\n        if (val !== null) {\n          const prop = fx.effectName;\n          if (fx.trans) {\n            finalTransform += prop + '(' + val + ') ';\n          }\n          else {\n            for (j = 0; j < elements.length; j++) {\n              // ******** DOM WRITE ****************\n              elements[j].style.setProperty(prop, val);\n            }\n          }\n        }\n      }\n    }\n    // place all transforms on the same property\n    if (finalTransform.length > 0) {\n      if (!this._isReverse && stepValue !== 1 || this._isReverse && stepValue !== 0) {\n        finalTransform += 'translateZ(0px)';\n      }\n      for (i = 0; i < elements.length; i++) {\n        // ******** DOM WRITE ****************\n        elements[i].style.setProperty('transform', finalTransform);\n      }\n    }\n  }\n  /**\n   * DOM WRITE\n   * NO RECURSION\n   */\n  _setTrans(dur, forcedLinearEasing) {\n    // Transition is not enabled if there are not effects\n    const elements = this._elements;\n    if (!elements || elements.length === 0 || !this._fxProperties) {\n      return;\n    }\n    // set the TRANSITION properties inline on the element\n    const easing = (forcedLinearEasing ? 'linear' : this.getEasing());\n    const durString = dur + 'ms';\n    for (const { style } of elements) {\n      if (dur > 0) {\n        // ******** DOM WRITE ****************\n        style.transitionDuration = durString;\n        // each animation can have a different easing\n        if (easing !== null) {\n          // ******** DOM WRITE ****************\n          style.transitionTimingFunction = easing;\n        }\n      }\n      else {\n        style.transitionDuration = '0';\n      }\n    }\n  }\n  /**\n   * DOM READ\n   * DOM WRITE\n   * RECURSION\n   */\n  _beforeAnimation() {\n    // fire off all the \"before\" function that have DOM READS in them\n    // elements will be in the DOM, however visibily hidden\n    // so we can read their dimensions if need be\n    // ******** DOM READ ****************\n    this._fireBeforeReadFunc();\n    // ******** DOM READS ABOVE / DOM WRITES BELOW ****************\n    // fire off all the \"before\" function that have DOM WRITES in them\n    // ******** DOM WRITE ****************\n    this._fireBeforeWriteFunc();\n    // stage all of the before css classes and inline styles\n    // ******** DOM WRITE ****************\n    this._setBeforeStyles();\n  }\n  /**\n   * DOM WRITE\n   * RECURSION\n   */\n  _setBeforeStyles() {\n    const children = this._childAnimations;\n    if (children) {\n      for (const child of children) {\n        child._setBeforeStyles();\n      }\n    }\n    const elements = this._elements;\n    // before the animations have started\n    // only set before styles if animation is not reversed\n    if (!elements || elements.length === 0 || this._isReverse) {\n      return;\n    }\n    const addClasses = this._beforeAddClasses;\n    const removeClasses = this._beforeRemoveClasses;\n    for (const el of elements) {\n      const elementClassList = el.classList;\n      // css classes to add before the animation\n      if (addClasses) {\n        for (const c of addClasses) {\n          // ******** DOM WRITE ****************\n          elementClassList.add(c);\n        }\n      }\n      // css classes to remove before the animation\n      if (removeClasses) {\n        for (const c of removeClasses) {\n          // ******** DOM WRITE ****************\n          elementClassList.remove(c);\n        }\n      }\n      // inline styles to add before the animation\n      if (this._beforeStyles) {\n        for (const [key, value] of Object.entries(this._beforeStyles)) {\n          // ******** DOM WRITE ****************\n          el.style.setProperty(key, value);\n        }\n      }\n    }\n  }\n  /**\n   * DOM READ\n   * RECURSION\n   */\n  _fireBeforeReadFunc() {\n    const children = this._childAnimations;\n    if (children) {\n      for (const child of children) {\n        // ******** DOM READ ****************\n        child._fireBeforeReadFunc();\n      }\n    }\n    const readFunctions = this._readCallbacks;\n    if (readFunctions) {\n      for (const callback of readFunctions) {\n        // ******** DOM READ ****************\n        callback();\n      }\n    }\n  }\n  /**\n   * DOM WRITE\n   * RECURSION\n   */\n  _fireBeforeWriteFunc() {\n    const children = this._childAnimations;\n    if (children) {\n      for (const child of children) {\n        // ******** DOM WRITE ****************\n        child._fireBeforeWriteFunc();\n      }\n    }\n    const writeFunctions = this._writeCallbacks;\n    if (writeFunctions) {\n      for (const callback of writeFunctions) {\n        // ******** DOM WRITE ****************\n        callback();\n      }\n    }\n  }\n  /**\n   * DOM WRITE\n   */\n  _setAfterStyles() {\n    const elements = this._elements;\n    if (!elements) {\n      return;\n    }\n    for (const el of elements) {\n      const elementClassList = el.classList;\n      // remove the transition duration/easing\n      // ******** DOM WRITE ****************\n      el.style.transitionDuration = el.style.transitionTimingFunction = '';\n      if (this._isReverse) {\n        // finished in reverse direction\n        // css classes that were added before the animation should be removed\n        const beforeAddClasses = this._beforeAddClasses;\n        if (beforeAddClasses) {\n          for (const c of beforeAddClasses) {\n            elementClassList.remove(c);\n          }\n        }\n        // css classes that were removed before the animation should be added\n        const beforeRemoveClasses = this._beforeRemoveClasses;\n        if (beforeRemoveClasses) {\n          for (const c of beforeRemoveClasses) {\n            elementClassList.add(c);\n          }\n        }\n        // inline styles that were added before the animation should be removed\n        const beforeStyles = this._beforeStyles;\n        if (beforeStyles) {\n          for (const propName of Object.keys(beforeStyles)) {\n            // ******** DOM WRITE ****************\n            el.style.removeProperty(propName);\n          }\n        }\n      }\n      else {\n        // finished in forward direction\n        // css classes to add after the animation\n        const afterAddClasses = this._afterAddClasses;\n        if (afterAddClasses) {\n          for (const c of afterAddClasses) {\n            // ******** DOM WRITE ****************\n            elementClassList.add(c);\n          }\n        }\n        // css classes to remove after the animation\n        const afterRemoveClasses = this._afterRemoveClasses;\n        if (afterRemoveClasses) {\n          for (const c of afterRemoveClasses) {\n            // ******** DOM WRITE ****************\n            elementClassList.remove(c);\n          }\n        }\n        // inline styles to add after the animation\n        const afterStyles = this._afterStyles;\n        if (afterStyles) {\n          for (const [key, value] of Object.entries(afterStyles)) {\n            el.style.setProperty(key, value);\n          }\n        }\n      }\n    }\n  }\n  /**\n   * DOM WRITE\n   * NO RECURSION\n   */\n  _willChange(addWillChange) {\n    let wc;\n    const effects = this._fxProperties;\n    let willChange;\n    if (addWillChange && effects) {\n      wc = [];\n      for (const effect of effects) {\n        const propWC = effect.wc;\n        if (propWC === 'webkitTransform') {\n          wc.push('transform', '-webkit-transform');\n        }\n        else if (propWC !== undefined) {\n          wc.push(propWC);\n        }\n      }\n      willChange = wc.join(',');\n    }\n    else {\n      willChange = '';\n    }\n    const elements = this._elements;\n    if (elements) {\n      for (const el of elements) {\n        // ******** DOM WRITE ****************\n        el.style.setProperty('will-change', willChange);\n      }\n    }\n  }\n  /**\n   * Start the animation with a user controlled progress.\n   */\n  progressStart() {\n    // ensure all past transition end events have been cleared\n    this._clearAsync();\n    // ******** DOM READ/WRITE ****************\n    this._beforeAnimation();\n    // ******** DOM WRITE ****************\n    this._progressStart();\n  }\n  /**\n   * DOM WRITE\n   * RECURSION\n   */\n  _progressStart() {\n    const children = this._childAnimations;\n    if (children) {\n      for (const child of children) {\n        // ******** DOM WRITE ****************\n        child._progressStart();\n      }\n    }\n    // force no duration, linear easing\n    // ******** DOM WRITE ****************\n    this._setTrans(0, true);\n    // ******** DOM WRITE ****************\n    this._willChange(true);\n  }\n  /**\n   * Set the progress step for this animation.\n   * progressStep() is not debounced, so it should not be called faster than 60FPS.\n   */\n  progressStep(stepValue) {\n    // only update if the last update was more than 16ms ago\n    stepValue = Math.min(1, Math.max(0, stepValue));\n    const children = this._childAnimations;\n    if (children) {\n      for (const child of children) {\n        // ******** DOM WRITE ****************\n        child.progressStep(stepValue);\n      }\n    }\n    // ******** DOM WRITE ****************\n    this._progress(stepValue);\n  }\n  /**\n   * End the progress animation.\n   */\n  progressEnd(shouldComplete, currentStepValue, dur = -1) {\n    if (this._isReverse) {\n      // if the animation is going in reverse then\n      // flip the step value: 0 becomes 1, 1 becomes 0\n      currentStepValue = 1 - currentStepValue;\n    }\n    const stepValue = shouldComplete ? 1 : 0;\n    const diff = Math.abs(currentStepValue - stepValue);\n    if (dur < 0) {\n      dur = this._duration || 0;\n    }\n    else if (diff < 0.05) {\n      dur = 0;\n    }\n    this._isAsync = (dur > 30);\n    this._progressEnd(shouldComplete, stepValue, dur, this._isAsync);\n    if (this._isAsync) {\n      // for the root animation only\n      // set the async TRANSITION END event\n      // and run onFinishes when the transition ends\n      // ******** DOM WRITE ****************\n      this._asyncEnd(dur, shouldComplete);\n      // this animation has a duration so we need another RAF\n      // for the CSS TRANSITION properties to kick in\n      if (!this._destroyed) {\n        raf(() => {\n          this._playToStep(stepValue);\n        });\n      }\n    }\n  }\n  /**\n   * DOM WRITE\n   * RECURSION\n   */\n  _progressEnd(shouldComplete, stepValue, dur, isAsync) {\n    const children = this._childAnimations;\n    if (children) {\n      for (const child of children) {\n        // ******** DOM WRITE ****************\n        child._progressEnd(shouldComplete, stepValue, dur, isAsync);\n      }\n    }\n    if (!isAsync) {\n      // stop immediately\n      // set all the animations to their final position\n      // ******** DOM WRITE ****************\n      this._progress(stepValue);\n      this._willChange(false);\n      this._setAfterStyles();\n      this._didFinish(shouldComplete);\n    }\n    else {\n      // animate it back to it's ending position\n      this.isPlaying = true;\n      this.hasCompleted = false;\n      this._hasDur = true;\n      // ******** DOM WRITE ****************\n      this._willChange(true);\n      this._setTrans(dur, false);\n    }\n  }\n  /**\n   * Add a callback to fire when the animation has finished.\n   */\n  onFinish(callback, opts) {\n    if (opts && opts.clearExistingCallbacks) {\n      this._onFinishCallbacks = this._onFinishOneTimeCallbacks = undefined;\n    }\n    if (opts && opts.oneTimeCallback) {\n      this._onFinishOneTimeCallbacks = this._onFinishOneTimeCallbacks || [];\n      this._onFinishOneTimeCallbacks.push(callback);\n    }\n    else {\n      this._onFinishCallbacks = this._onFinishCallbacks || [];\n      this._onFinishCallbacks.push(callback);\n    }\n    return this;\n  }\n  /**\n   * NO DOM\n   * RECURSION\n   */\n  _didFinishAll(hasCompleted, finishAsyncAnimations, finishNoDurationAnimations) {\n    const children = this._childAnimations;\n    if (children) {\n      for (const child of children) {\n        child._didFinishAll(hasCompleted, finishAsyncAnimations, finishNoDurationAnimations);\n      }\n    }\n    if (finishAsyncAnimations && this._isAsync || finishNoDurationAnimations && !this._isAsync) {\n      this._didFinish(hasCompleted);\n    }\n  }\n  /**\n   * NO RECURSION\n   */\n  _didFinish(hasCompleted) {\n    this.isPlaying = false;\n    this.hasCompleted = hasCompleted;\n    if (this._onFinishCallbacks) {\n      // run all finish callbacks\n      for (const callback of this._onFinishCallbacks) {\n        callback(this);\n      }\n    }\n    if (this._onFinishOneTimeCallbacks) {\n      // run all \"onetime\" finish callbacks\n      for (const callback of this._onFinishOneTimeCallbacks) {\n        callback(this);\n      }\n      this._onFinishOneTimeCallbacks.length = 0;\n    }\n  }\n  /**\n   * Reverse the animation.\n   */\n  reverse(shouldReverse = true) {\n    const children = this._childAnimations;\n    if (children) {\n      for (const child of children) {\n        child.reverse(shouldReverse);\n      }\n    }\n    this._isReverse = !!shouldReverse;\n    return this;\n  }\n  /**\n   * Recursively destroy this animation and all child animations.\n   */\n  destroy() {\n    this._didFinish(false);\n    this._destroyed = true;\n    const children = this._childAnimations;\n    if (children) {\n      for (const child of children) {\n        child.destroy();\n      }\n    }\n    this._clearAsync();\n    if (this._elements) {\n      this._elements.length = 0;\n    }\n    if (this._readCallbacks) {\n      this._readCallbacks.length = 0;\n    }\n    if (this._writeCallbacks) {\n      this._writeCallbacks.length = 0;\n    }\n    this.parent = undefined;\n    if (this._childAnimations) {\n      this._childAnimations.length = 0;\n    }\n    if (this._onFinishCallbacks) {\n      this._onFinishCallbacks.length = 0;\n    }\n    if (this._onFinishOneTimeCallbacks) {\n      this._onFinishOneTimeCallbacks.length = 0;\n    }\n  }\n  /**\n   * NO DOM\n   */\n  _transEl() {\n    // get the lowest level element that has an Animator\n    const children = this._childAnimations;\n    if (children) {\n      for (const child of children) {\n        const targetEl = child._transEl();\n        if (targetEl) {\n          return targetEl;\n        }\n      }\n    }\n    return (this._hasTweenEffect &&\n      this._hasDur &&\n      this._elements !== undefined &&\n      this._elements.length > 0 ?\n      this._elements[0] : null);\n  }\n}\n\nfunction create(animationBuilder, baseEl, opts) {\n  if (animationBuilder) {\n    return animationBuilder(Animator, baseEl, opts);\n  }\n  return Promise.resolve(new Animator());\n}\n\nexport { create };\n"],"sourceRoot":""}